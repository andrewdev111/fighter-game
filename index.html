<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Retro Fighter (Single Player)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Press Start 2P", cursive;
        background-color: #1a1a1a;
        color: #fff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        overflow: hidden;
        padding: 10px;
      }
      #gameContainer,
      #uiContainer {
        border: 4px solid #555;
        background-color: #0f0f0f;
        position: relative;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        text-align: center;
        padding: 20px;
        border-radius: 8px;
      }
      #gameContainer {
        padding: 0;
      }
      canvas {
        display: block;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-crisp-edges;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        background-color: #282840;
        width: 100%;
        height: 100%;
      }
      .game-button,
      .fighter-button {
        font-family: "Press Start 2P", cursive;
        background-color: #ff4500;
        color: white;
        border: 2px solid #fff;
        padding: 12px 24px;
        text-transform: uppercase;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.1s;
        box-shadow: 4px 4px 0px #c03400;
        margin: 10px;
        border-radius: 4px;
      }
      .fighter-button.red {
        background-color: #d9534f;
        box-shadow: 4px 4px 0px #b0403c;
      }
      .fighter-button.red:hover {
        background-color: #c9302c;
      }
      .fighter-button.blue {
        background-color: #5bc0de;
        box-shadow: 4px 4px 0px #46b8da;
      }
      .fighter-button.blue:hover {
        background-color: #31b0d5;
      }

      .game-button:hover,
      .fighter-button:hover {
        transform: translateY(-2px);
      }
      .game-button:active,
      .fighter-button:active {
        box-shadow: 1px 1px 0px #aa3000;
        transform: translate(3px, 3px);
      }
      .game-overlay {
        /* Used for Game Over screen */
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 10;
        padding: 20px;
        box-sizing: border-box;
      }
      .game-overlay h2,
      #uiContainer h2 {
        font-size: 1.8em;
        margin-bottom: 20px;
        color: #ffdd00;
      }
      #uiContainer p {
        margin-bottom: 15px;
        line-height: 1.6;
      }

      .health-bar-container {
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        padding: 15px 25px;
        box-sizing: border-box;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 5;
      }
      #player1HealthContainer,
      #player2HealthContainer {
        width: 100%;
        max-width: 50px;
        min-width: 50px;
      }
      .health-bar {
        height: 30px;
        border: 3px solid #fff;
        background-color: #555;
        width: 100%;
        max-width: 50px;
        min-width: 50px;
      }
      .health-bar-inner {
        height: 100%;
        background-color: #00ff00;
        width: 100%;
        transition: width 0.2s ease-out;
      }
      .health-bar-label {
        font-size: 18px;
        font-weight: bold;
        color: #fff;
        margin-bottom: 5px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      }
      #player1HealthContainer .health-bar-inner {
        background-color: #ff3333;
      } /* Dowand's bar is Red */
      #player2HealthContainer .health-bar-inner {
        background-color: #3333ff;
      } /* Ewon's bar is Blue */

      .controls-info {
        margin-top: 20px;
        background-color: #222;
        padding: 15px;
        border: 2px solid #444;
        border-radius: 8px;
        text-align: center;
        font-size: 0.75em;
        line-height: 1.7;
        max-width: 90%;
        width: 600px;
      }
      .controls-info h3 {
        font-size: 1.2em;
        color: #ffdd00;
        margin-bottom: 10px;
        text-align: center;
      }
      .controls-info strong {
        color: #ff8c00;
      }

      .touch-controls {
        display: none;
      }
      @media (max-width: 768px) {
        .controls-info {
          font-size: 0.6em;
          width: 95%;
          line-height: 1.5;
        }
        .health-bar-label {
          font-size: 0.6em;
        }
        .health-bar {
          height: 25px;
          max-width: 180px;
        }
        .game-button,
        .fighter-button {
          padding: 10px 18px;
          font-size: 0.9em;
        }
        .game-overlay h2,
        #uiContainer h2 {
          font-size: 1.5em;
        }
        .touch-controls {
          display: flex;
          position: fixed;
          bottom: 3px;
          left: 0;
          width: 100%;
          padding: 3px;
          box-sizing: border-box;
          justify-content: center;
          z-index: 100;
        }
        .touch-controls-group {
          display: flex;
          flex-wrap: nowrap;
          gap: 2px;
          justify-content: center;
        }
        .touch-actions,
        .touch-movement {
          display: flex;
          gap: 2px;
        }
        .touch-button {
          font-family: "Press Start 2P", cursive;
          background-color: rgba(255, 69, 0, 0.7);
          color: white;
          border: 1px solid rgba(255, 255, 255, 0.8);
          padding: 8px;
          min-width: 35px;
          text-align: center;
          cursor: pointer;
          border-radius: 5px;
          user-select: none;
          box-shadow: 1px 1px 0px rgba(170, 50, 0, 0.7);
          font-size: 0.6em;
        }
        .touch-button:active {
          background-color: rgba(224, 62, 0, 0.9);
          box-shadow: 0px 0px 0px rgba(170, 50, 0, 0.7);
          transform: translate(1px, 1px);
        }
      }
      @media (max-width: 480px) {
        .touch-button {
          padding: 6px;
          min-width: 30px;
          font-size: 0.5em;
        }
        .controls-info {
          font-size: 0.55em;
        }
      }
      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="uiContainer">
      <!-- –≠–∫—Ä–∞–Ω 1: –í—ã–±–æ—Ä –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ -->
      <div id="characterSelectionScreen">
        <h2>Choose Your Fighter!</h2>
        <p style="font-size: 0.8em; color: #ccc; margin-bottom: 20px">
          Select your character to play with
        </p>

        <div
          style="
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
          "
        >
          <div
            style="
              text-align: center;
              padding: 15px;
              border: 2px solid #d9534f;
              border-radius: 8px;
              background: rgba(217, 83, 79, 0.1);
            "
          >
            <div
              style="
                width: 80px;
                height: 80px;
                background: #d9534f;
                margin: 0 auto 10px;
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 2em;
              "
            >
              ü•ä
            </div>
            <button id="selectDowand" class="fighter-button red">
              Select Dowand
            </button>
            <p style="font-size: 0.6em; color: #ccc; margin-top: 8px">
              Red Fighter
            </p>
          </div>

          <div
            style="
              text-align: center;
              padding: 15px;
              border: 2px solid #5bc0de;
              border-radius: 8px;
              background: rgba(91, 192, 222, 0.1);
            "
          >
            <div
              style="
                width: 80px;
                height: 80px;
                background: #5bc0de;
                margin: 0 auto 10px;
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 2em;
              "
            >
              üë§
            </div>
            <button id="selectEwon" class="fighter-button blue">
              Select Ewon
            </button>
            <p style="font-size: 0.6em; color: #ccc; margin-top: 8px">
              Blue Fighter
            </p>
          </div>
        </div>
      </div>

      <!-- –≠–∫—Ä–∞–Ω 2: –í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞ –∏–≥—Ä—ã -->
      <div id="gameModeSelectionScreen" class="hidden">
        <h2>Choose Game Mode</h2>
        <p style="font-size: 0.8em; color: #ccc; margin-bottom: 20px">
          Playing as:
          <span id="selectedFighterName" style="color: #ffdd00"></span>
        </p>

        <!-- –ë—ã—Å—Ç—Ä–∞—è –∏–≥—Ä–∞ (–æ—á–µ—Ä–µ–¥—å) -->
        <div
          style="
            margin-bottom: 25px;
            padding: 20px;
            border: 2px solid #ff6600;
            border-radius: 8px;
            background: rgba(255, 102, 0, 0.1);
          "
        >
          <h3 style="color: #ff6600; margin-bottom: 15px">‚ö° Quick Match</h3>
          <p style="font-size: 0.7em; color: #ccc; margin-bottom: 15px">
            Automatic matchmaking with random online players
          </p>
          <button
            id="quickMatchBtn"
            class="game-button"
            style="background: #ff6600"
          >
            Find Match
          </button>
        </div>

        <!-- –ü—Ä–∏–≤–∞—Ç–Ω–∞—è –∏–≥—Ä–∞ -->
        <div
          style="
            padding: 20px;
            border: 2px solid #0066ff;
            border-radius: 8px;
            background: rgba(0, 102, 255, 0.1);
          "
        >
          <h3 style="color: #0066ff; margin-bottom: 15px">üîí Private Room</h3>
          <p style="font-size: 0.7em; color: #ccc; margin-bottom: 15px">
            Create or join a private room to play with friends
          </p>
          <button
            id="createRoomBtn"
            class="game-button"
            style="background: #0066ff; margin-bottom: 15px"
          >
            Create Room
          </button>
          <div style="display: flex; gap: 10px; align-items: center">
            <input
              type="number"
              id="roomIdInput"
              placeholder="Room Code"
              style="
                padding: 8px;
                flex: 1;
                border: 2px solid #555;
                background: #222;
                color: white;
                font-family: 'Press Start 2P', cursive;
                font-size: 0.8em;
              "
            />
            <button
              id="joinRoomBtn"
              class="game-button"
              style="background: #0066ff"
            >
              Join Room
            </button>
          </div>
        </div>

        <button
          id="backToCharacterBtn"
          class="game-button"
          style="margin-top: 20px; background: #666"
        >
          ‚Üê Back to Character Selection
        </button>
      </div>

      <!-- –≠–∫—Ä–∞–Ω 3: –û–∂–∏–¥–∞–Ω–∏–µ/–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ -->
      <div id="waitingScreen" class="hidden">
        <h2 id="waitingTitle">Waiting...</h2>
        <p
          id="waitingSubtitle"
          style="font-size: 0.8em; color: #ccc; margin-bottom: 20px"
        ></p>

        <!-- –°—Ç–∞—Ç—É—Å –æ—á–µ—Ä–µ–¥–∏ -->
        <div
          id="queueStatus"
          style="
            display: none;
            margin-bottom: 20px;
            padding: 15px;
            border: 2px solid #ff6600;
            border-radius: 8px;
            background: rgba(255, 102, 0, 0.1);
          "
        >
          <h3 style="color: #ff6600; margin-bottom: 10px">
            üîç Searching for opponent...
          </h3>
          <p style="font-size: 0.8em; color: #ccc">
            Time elapsed: <span id="queueTime" style="color: #ff6600">0</span>s
          </p>
        </div>

        <!-- –°—Ç–∞—Ç—É—Å –∫–æ–º–Ω–∞—Ç—ã -->
        <div
          id="roomStatus"
          style="
            display: none;
            margin-bottom: 20px;
            padding: 15px;
            border: 2px solid #0066ff;
            border-radius: 8px;
            background: rgba(0, 102, 255, 0.1);
          "
        >
          <h3 style="color: #0066ff; margin-bottom: 10px">üîí Private Room</h3>
          <p
            id="roomInfo"
            style="font-size: 0.8em; color: #ccc; margin-bottom: 10px"
          >
            Room: <span id="roomNumber" style="color: #0066ff"></span>
          </p>
          <p style="font-size: 0.7em; color: #999">
            Waiting for opponent to join...
          </p>
          <button
            id="readyBtn"
            class="game-button"
            style="display: none; margin-top: 15px; background: #00aa00"
          >
            Ready!
          </button>
        </div>

        <button id="cancelBtn" class="game-button" style="background: #aa0000">
          Cancel
        </button>

        <!-- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ —Å–µ—Ç–∏ -->
        <div
          id="networkInfo"
          style="margin-top: 20px; font-size: 0.7em; color: #888"
        >
          <div id="connectionStatus">Connecting...</div>
          <div id="pingInfo" style="display: none">
            Ping: <span id="pingValue">0</span>ms
          </div>
          <div id="playersOnline" style="display: none">
            Players online: <span id="onlineCount">0</span>
          </div>
        </div>
      </div>
    </div>

    <div id="gameContainer" class="rounded-lg overflow-hidden hidden">
      <div id="healthBars" class="health-bar-container">
        <div id="player1HealthContainer">
          <div id="player1NameLabel" class="health-bar-label">Dowand</div>
          <div class="health-bar">
            <div id="player1Health" class="health-bar-inner"></div>
          </div>
        </div>
        <div id="player2HealthContainer" style="text-align: right">
          <div id="player2NameLabel" class="health-bar-label">Ewon</div>
          <div class="health-bar">
            <div id="player2Health" class="health-bar-inner"></div>
          </div>
        </div>
      </div>
      <canvas id="gameCanvas"></canvas>
      <div id="gameOverScreen" class="game-overlay hidden">
        <h2 id="winnerMessage"></h2>
        <button id="playAgainButton" class="game-button">Play Again</button>
      </div>
    </div>

    <div class="controls-info">
      <h3>Controls</h3>
      <p>
        <strong>A,D</strong> (Move), <strong>W</strong> (Jump),
        <strong>S</strong> (Block), <strong>Z</strong> (Arm),
        <strong>X</strong> (Leg), <strong>SPACE</strong> (Shoot)
      </p>
    </div>

    <div id="touchControlsContainer" class="touch-controls hidden"></div>

    <script>
      // DOM elements for the new three-screen structure
      const characterSelectionScreen = document.getElementById(
        "characterSelectionScreen"
      );
      const gameModeSelectionScreen = document.getElementById(
        "gameModeSelectionScreen"
      );
      const waitingScreen = document.getElementById("waitingScreen");
      const gameUiContainer = document.getElementById("uiContainer");
      const gameMainContainer = document.getElementById("gameContainer");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const winnerMessage = document.getElementById("winnerMessage");
      const playAgainButton = document.getElementById("playAgainButton");

      const player1HealthBar = document.getElementById("player1Health");
      const player2HealthBar = document.getElementById("player2Health");
      const player1NameLabel = document.getElementById("player1NameLabel");
      const player2NameLabel = document.getElementById("player2NameLabel");
      const touchControlsContainer = document.getElementById(
        "touchControlsContainer"
      );

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Å–ø—Ä–∞–π—Ç–æ–≤
      let trampSprite = null;
      let maskSprite = null;
      let spritesLoaded = false;

      // Game state
      let selectedFighter = null; // Track the selected character
      let currentScreen = "character"; // Current active screen: character, gamemode, waiting, game

      const CANVAS_WIDTH = 640;
      const CANVAS_HEIGHT = 360;
      const GROUND_Y = CANVAS_HEIGHT - 50;
      const PLAYER_WIDTH = 70;
      const PLAYER_HEIGHT = 70;
      const PLAYER_SPEED = 4;
      const JUMP_FORCE = 13;
      const GRAVITY = 0.7;
      const MAX_HEALTH = 100;
      const ARM_STRIKE_DAMAGE = 10;
      const ARM_STRIKE_RANGE_X = 50;
      const ARM_STRIKE_RANGE_Y = 20;
      const LEG_STRIKE_DAMAGE = 12;
      const LEG_STRIKE_RANGE_X = 60;
      const LEG_STRIKE_RANGE_Y = 15;
      const MELEE_ATTACK_DURATION = 15;
      const BULLET_DAMAGE = 15;
      const BULLET_SPEED = 8;
      const BULLET_WIDTH = 15;
      const BULLET_HEIGHT = 8;
      const SHOOT_COOLDOWN = 60;
      const HIT_STUN_DURATION = 20;
      const KNOCKBACK_FORCE = 5;
      const BLOCK_DAMAGE_REDUCTION = 1;

      // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø—Ä–∞–π—Ç–æ–≤
      function loadSprites() {
        return new Promise((resolve, reject) => {
          let loadedCount = 0;
          let errorCount = 0;
          const totalSprites = 2;

          function checkAllLoaded() {
            loadedCount++;
            console.log(`–°–ø—Ä–∞–π—Ç –∑–∞–≥—Ä—É–∂–µ–Ω (${loadedCount}/${totalSprites})`);
            if (loadedCount === totalSprites) {
              spritesLoaded = true;
              console.log("–í—Å–µ —Å–ø—Ä–∞–π—Ç—ã —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã!");
              resolve();
            }
          }

          function handleError(spriteName) {
            errorCount++;
            console.warn(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ø—Ä–∞–π—Ç–∞: ${spriteName}`);
            if (errorCount + loadedCount === totalSprites) {
              console.log(
                "–ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø—Ä–∞–π—Ç–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —Å –æ—à–∏–±–∫–∞–º–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback"
              );
              resolve(); // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –¥–∞–∂–µ —Å –æ—à–∏–±–∫–∞–º–∏
            }
          }

          // Timeout –Ω–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è
          setTimeout(() => {
            if (loadedCount < totalSprites) {
              console.warn(
                "Timeout –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ø—Ä–∞–π—Ç–æ–≤, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ü–≤–µ—Ç–Ω—ã–µ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∏"
              );
              resolve();
            }
          }, 5000); // 5 —Å–µ–∫—É–Ω–¥ timeout

          trampSprite = new Image();
          trampSprite.onload = checkAllLoaded;
          trampSprite.onerror = () => handleError("tramp.png");
          trampSprite.src = "assets/tramp.png";

          maskSprite = new Image();
          maskSprite.onload = checkAllLoaded;
          maskSprite.onerror = () => handleError("mask.png");
          maskSprite.src = "assets/mask.png";
        });
      }

      let gameState = "init";
      let humanPlayer, cpuOpponent;
      let bullets = []; // Single bullets array for both players
      let keys = {};
      let animationFrameId;

      // WebSocket –∫–ª–∏–µ–Ω—Ç
      let ws = null;
      let playerId = null;
      let roomId = null;
      let isMultiplayer = false;
      let networkPlayers = new Map();
      let lastPingTime = 0;
      let latency = 0;
      let inQueue = false;
      let queueStartTime = 0;
      let queueTimer = null;
      let onlineCount = 0;
      let lastInputSent = 0;
      let lastInputData = null;
      const INPUT_SEND_INTERVAL = 50; // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –º–∞–∫—Å–∏–º—É–º –∫–∞–∂–¥—ã–µ 50–º—Å (20 FPS)

      // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ WebSocket —Å–µ—Ä–≤–µ—Ä—É
      function connectToServer() {
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º URL —Å–µ—Ä–≤–µ—Ä–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å—Ä–µ–¥—ã
        let wsUrl;
        if (
          window.location.hostname === "localhost" ||
          window.location.hostname === "127.0.0.1"
        ) {
          // –õ–æ–∫–∞–ª—å–Ω–∞—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞
          wsUrl = "ws://localhost:3000";
        } else {
          // –ü—Ä–æ–¥–∞–∫—à–Ω
          wsUrl = "wss://fighter-game.onrender.com";
        }

        console.log(`Connecting to: ${wsUrl}`);
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          console.log("–ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ —Å–µ—Ä–≤–µ—Ä—É");
          // –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º —á–∞—Å—Ç–æ—Ç—É –∏–∑–º–µ—Ä–µ–Ω–∏—è –ø–∏–Ω–≥–∞ –¥–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞
          const isProduction =
            window.location.hostname !== "localhost" &&
            window.location.hostname !== "127.0.0.1";
          const pingInterval = isProduction ? 15000 : 5000; // 15 —Å–µ–∫ –≤ –ø—Ä–æ–¥–µ, 5 —Å–µ–∫ –ª–æ–∫–∞–ª—å–Ω–æ
          const statsInterval = isProduction ? 30000 : 10000; // 30 —Å–µ–∫ –≤ –ø—Ä–æ–¥–µ, 10 —Å–µ–∫ –ª–æ–∫–∞–ª—å–Ω–æ

          setInterval(measurePing, pingInterval);
          // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –æ–Ω–ª–∞–π–Ω
          getOnlineStats();
          setInterval(getOnlineStats, statsInterval);
        };

        ws.onmessage = (event) => {
          const message = JSON.parse(event.data);
          handleServerMessage(message);
        };

        ws.onclose = () => {
          console.log("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Å–µ—Ä–≤–µ—Ä–æ–º –∑–∞–∫—Ä—ã—Ç–æ");
          // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ—á–µ—Ä–µ–¥–∏
          if (inQueue) {
            stopQueueTimer();
            inQueue = false;
          }
          // –ü–æ–ø—ã—Ç–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
          setTimeout(connectToServer, 3000);
        };

        ws.onerror = (error) => {
          console.error("–û—à–∏–±–∫–∞ WebSocket:", error);
        };
      }

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
      function handleServerMessage(message) {
        switch (message.type) {
          case "connected":
            playerId = message.playerId;
            console.log(`–ü–æ–ª—É—á–µ–Ω ID –∏–≥—Ä–æ–∫–∞: ${playerId}`);
            getOnlineStats(); // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –æ–Ω–ª–∞–π–Ω –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
            break;

          case "roomCreated":
            roomId = message.roomId;
            console.log(`–°–æ–∑–¥–∞–Ω–∞ –∫–æ–º–Ω–∞—Ç–∞: ${roomId}`);
            document.getElementById("roomNumber").textContent = roomId;
            document.getElementById("readyBtn").style.display = "inline-block";
            break;

          case "roomJoined":
            roomId = message.roomId;
            console.log(`–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ: ${roomId}`);
            document.getElementById("roomNumber").textContent = roomId;
            document.getElementById("readyBtn").style.display = "inline-block";
            break;

          case "playerJoined":
            console.log(`–ò–≥—Ä–æ–∫ ${message.playerId} –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è`);
            break;

          case "fighterSelected":
            console.log(`–ò–≥—Ä–æ–∫ ${message.playerId} –≤—ã–±—Ä–∞–ª ${message.fighter}`);
            break;

          case "gameStart":
            isMultiplayer = true;
            startMultiplayerGame(message.players);
            break;

          case "gameUpdate":
            updateNetworkPlayers(message);
            break;

          case "playerInput":
            handleNetworkPlayerInput(message);
            break;

          case "playerHit":
            handlePlayerHit(message);
            break;

          case "bulletHit":
            handleBulletHit(message);
            break;

          case "playerDisconnected":
            console.log(`–ò–≥—Ä–æ–∫ ${message.playerId} –æ—Ç–∫–ª—é—á–∏–ª—Å—è`);
            break;

          case "pong":
            // –ü—Ä–∞–≤–∏–ª—å–Ω–æ —Å—á–∏—Ç–∞–µ–º RTT (Round Trip Time)
            latency = Date.now() - lastPingTime;
            break;

          case "queueJoined":
            inQueue = true;
            queueStartTime = Date.now();
            startQueueTimer();
            console.log("–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ –æ—á–µ—Ä–µ–¥–∏");
            break;

          case "queueLeft":
            inQueue = false;
            stopQueueTimer();
            console.log("–í—ã—à–µ–ª –∏–∑ –æ—á–µ—Ä–µ–¥–∏");
            break;

          case "matchFound":
            inQueue = false;
            stopQueueTimer();
            roomId = message.roomId;
            console.log(`–ú–∞—Ç—á –Ω–∞–π–¥–µ–Ω! –ö–æ–º–Ω–∞—Ç–∞: ${roomId}`);
            // –ò–≥—Ä–∞ –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —á–µ—Ä–µ–∑ gameStart
            break;

          case "onlineStats":
            onlineCount = message.onlineCount;
            updateOnlineDisplay();
            break;

          case "roomLeft":
            console.log("Successfully left room");
            break;

          case "error":
            console.error("–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞:", message.message);
            alert("–û—à–∏–±–∫–∞: " + message.message);
            break;
        }
      }

      // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–∞ —Å–µ—Ä–≤–µ—Ä
      function sendToServer(message) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify(message));
        }
      }

      // –ò–∑–º–µ—Ä–µ–Ω–∏–µ –ø–∏–Ω–≥–∞
      function measurePing() {
        lastPingTime = Date.now();
        sendToServer({
          type: "ping",
          timestamp: lastPingTime,
        });
      }

      // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã
      function createRoom() {
        sendToServer({ type: "createRoom" });
      }

      // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ –∫–æ–º–Ω–∞—Ç–µ
      function joinRoom(roomIdInput) {
        sendToServer({
          type: "joinRoom",
          roomId: parseInt(roomIdInput),
        });
      }

      // –û—Ç–ø—Ä–∞–≤–∫–∞ –≤—ã–±–æ—Ä–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
      function selectNetworkFighter(fighter) {
        sendToServer({
          type: "selectFighter",
          fighter: fighter,
        });
      }

      // –û—Ç–ø—Ä–∞–≤–∫–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏
      function setReady() {
        sendToServer({ type: "ready" });
      }

      // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ –æ—á–µ—Ä–µ–¥–∏
      function joinQueue() {
        sendToServer({ type: "joinQueue" });
      }

      // –í—ã—Ö–æ–¥ –∏–∑ –æ—á–µ—Ä–µ–¥–∏
      function leaveQueue() {
        sendToServer({ type: "leaveQueue" });
      }

      // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –æ–Ω–ª–∞–π–Ω
      function getOnlineStats() {
        sendToServer({ type: "getOnlineCount" });
      }

      // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–æ–º –æ—á–µ—Ä–µ–¥–∏
      function startQueueTimer() {
        queueTimer = setInterval(() => {
          const elapsed = Math.floor((Date.now() - queueStartTime) / 1000);
          document.getElementById("queueTime").textContent = elapsed;
        }, 1000);
      }

      function stopQueueTimer() {
        if (queueTimer) {
          clearInterval(queueTimer);
          queueTimer = null;
        }
      }

      // –û–±–Ω–æ–≤–∏—Ç—å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ–Ω–ª–∞–π–Ω
      function updateOnlineDisplay() {
        const playersOnlineDiv = document.getElementById("playersOnline");
        const onlineCountSpan = document.getElementById("onlineCount");

        if (onlineCount > 0) {
          playersOnlineDiv.style.display = "block";
          onlineCountSpan.textContent = onlineCount;
        } else {
          playersOnlineDiv.style.display = "none";
        }
      }

      // –û—Ç–ø—Ä–∞–≤–∫–∞ –∏–≥—Ä–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞
      function sendPlayerInput(input) {
        if (!isMultiplayer) return;

        sendToServer({
          type: "playerInput",
          input: input,
          timestamp: Date.now(),
        });
      }

      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ—Ç–µ–≤—ã—Ö –∏–≥—Ä–æ–∫–æ–≤
      function updateNetworkPlayers(message) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∏–≥—Ä–æ–∫–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã
        if (!humanPlayer) {
          console.warn("humanPlayer is null, skipping network update");
          return;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏—è
        if (!message || !message.players || !Array.isArray(message.players)) {
          console.warn("Invalid network update message:", message);
          return;
        }

        const currentTime = Date.now();

        message.players.forEach((playerData) => {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–∞
          if (!playerData || typeof playerData.id === "undefined") {
            console.warn("Invalid player data:", playerData);
            return;
          }

          if (playerData.id === playerId) {
            // –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –ø—Ä–∏–º–µ–Ω—è–µ–º —Å–µ—Ä–≤–µ—Ä–Ω—É—é –∫–æ—Ä—Ä–µ–∫—Ü–∏—é —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –±–æ–ª—å—à–∏—Ö —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏—è—Ö
            if (humanPlayer) {
              // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤–∞–ª–∏–¥–Ω—ã
              if (
                typeof playerData.x === "number" &&
                typeof playerData.y === "number"
              ) {
                const deltaX = Math.abs(humanPlayer.x - playerData.x);
                const deltaY = Math.abs(humanPlayer.y - playerData.y);

                // –ï—Å–ª–∏ —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ, –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º
                if (deltaX > 20 || deltaY > 20) {
                  // –ü–ª–∞–≤–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –±–æ–ª—å—à–∏—Ö —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏—è—Ö
                  const correctionFactor = Math.min(0.3, latency / 1000);
                  humanPlayer.x =
                    humanPlayer.x * (1 - correctionFactor) +
                    playerData.x * correctionFactor;
                  humanPlayer.y =
                    humanPlayer.y * (1 - correctionFactor) +
                    playerData.y * correctionFactor;
                }
              }

              // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å —Å–µ—Ä–≤–µ—Ä–æ–º
              if (typeof playerData.health === "number") {
                humanPlayer.health = playerData.health;
              }
              if (typeof playerData.velocityY === "number") {
                humanPlayer.velocityY = playerData.velocityY;
              }
              if (typeof playerData.isJumping === "boolean") {
                humanPlayer.isJumping = playerData.isJumping;
              }
              if (typeof playerData.facing === "boolean") {
                humanPlayer.facingRight = playerData.facing;
              }
              if (typeof playerData.blocking === "boolean") {
                humanPlayer.isBlocking = playerData.blocking;
              }

              if (playerData.attacking) {
                humanPlayer.currentAttackType = playerData.attacking;
                humanPlayer.attackTimer = MELEE_ATTACK_DURATION;
              }
            }
          } else {
            // –û–±–Ω–æ–≤–ª—è–µ–º —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–µ–π
            if (cpuOpponent && cpuOpponent.networkId === playerData.id) {
              // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤–∞–ª–∏–¥–Ω—ã
              if (
                typeof playerData.x === "number" &&
                typeof playerData.y === "number"
              ) {
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏
                if (!cpuOpponent.lastNetworkUpdate) {
                  cpuOpponent.lastNetworkUpdate = {
                    x: cpuOpponent.x,
                    y: cpuOpponent.y,
                    time: currentTime,
                  };
                }

                const timeDelta =
                  currentTime - cpuOpponent.lastNetworkUpdate.time;

                // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è –¥–ª—è –ø—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–æ–π –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏
                if (timeDelta > 0 && timeDelta < 1000) {
                  // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏–µ –¥–µ–ª—å—Ç—ã
                  const velocityX =
                    (playerData.x - cpuOpponent.lastNetworkUpdate.x) /
                    timeDelta;
                  const velocityY =
                    (playerData.y - cpuOpponent.lastNetworkUpdate.y) /
                    timeDelta;

                  // –ü—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ —Å —É—á–µ—Ç–æ–º –ø–∏–Ω–≥–∞
                  const predictedX = playerData.x + velocityX * (latency / 2);
                  const predictedY = playerData.y + velocityY * (latency / 2);

                  // –ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–∏–Ω–≥–∞
                  let lerpFactor = Math.min(
                    0.15,
                    Math.max(0.05, 1.0 / (1 + latency / 100))
                  );

                  // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –±—ã—Å—Ç—Ä–æ –¥–≤–∏–∂–µ—Ç—Å—è, —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏
                  const speed = Math.sqrt(
                    velocityX * velocityX + velocityY * velocityY
                  );
                  if (speed > 0.1) {
                    lerpFactor = Math.min(0.25, lerpFactor * 1.5);
                  }

                  cpuOpponent.x =
                    cpuOpponent.x * (1 - lerpFactor) + predictedX * lerpFactor;
                  cpuOpponent.y =
                    cpuOpponent.y * (1 - lerpFactor) + predictedY * lerpFactor;
                }

                // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Ä–∞—Å—á–µ—Ç–∞
                cpuOpponent.lastNetworkUpdate = {
                  x: playerData.x,
                  y: playerData.y,
                  time: currentTime,
                };
              }

              // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
              if (typeof playerData.health === "number") {
                cpuOpponent.health = playerData.health;
              }
              if (typeof playerData.velocityY === "number") {
                cpuOpponent.velocityY = playerData.velocityY;
              }
              if (typeof playerData.isJumping === "boolean") {
                cpuOpponent.isJumping = playerData.isJumping;
              }
              if (typeof playerData.facing === "boolean") {
                cpuOpponent.facingRight = playerData.facing;
              }
              if (typeof playerData.blocking === "boolean") {
                cpuOpponent.isBlocking = playerData.blocking;
              }

              if (playerData.attacking) {
                cpuOpponent.currentAttackType = playerData.attacking;
                cpuOpponent.attackTimer = MELEE_ATTACK_DURATION;
              }
            }
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º –ø—É–ª–∏ –∏–∑ —Å–µ—Ä–≤–µ—Ä–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–µ–π
        if (message.bullets && Array.isArray(message.bullets)) {
          bullets = message.bullets
            .map((bulletData) => {
              // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –ø—É–ª–∏
              if (
                !bulletData ||
                typeof bulletData.x !== "number" ||
                typeof bulletData.y !== "number"
              ) {
                console.warn("Invalid bullet data:", bulletData);
                return null;
              }

              const bullet = new Bullet(
                bulletData.x,
                bulletData.y,
                1, // direction will be determined by velocity
                bulletData.ownerId
              );
              bullet.id = bulletData.id;
              bullet.velocityX = 8; // Default bullet speed
              bullet.velocityY = 0;

              // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–≤–µ—Ç –ø—É–ª–∏ –ø–æ –≤–ª–∞–¥–µ–ª—å—Ü—É
              if (bulletData.ownerId === playerId) {
                bullet.color = humanPlayer ? humanPlayer.color : "#ffff00";
              } else {
                bullet.color = cpuOpponent ? cpuOpponent.color : "#ff0000";
              }

              return bullet;
            })
            .filter((bullet) => bullet !== null);
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–æ—Å–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–≥—Ä–æ–∫–∏ —Å—É—â–µ—Å—Ç–≤—É—é—Ç
        if (humanPlayer && cpuOpponent) {
          updateHealthBars();
        }
      }

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ —Å–µ—Ç–µ–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞
      function handleNetworkPlayerInput(message) {
        if (message.playerId !== playerId) {
          const playerData = message.input;
          networkPlayers.set(message.playerId, {
            ...networkPlayers.get(message.playerId),
            ...playerData,
            timestamp: message.timestamp,
          });
        }
      }

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –∞—Ç–∞–∫–∏ –±–ª–∏–∂–Ω–µ–≥–æ –±–æ—è
      function handlePlayerHit(message) {
        const actionType = message.blocked ? "blocked attack from" : "hit by";
        console.log(
          `Player ${actionType}: ${message.attackerId} ‚Üí ${message.targetId}, damage: ${message.damage}`
        );

        let target = null;
        if (message.targetId === playerId) {
          target = humanPlayer;
        } else if (cpuOpponent && cpuOpponent.networkId === message.targetId) {
          target = cpuOpponent;
        }

        if (target) {
          // –û–±–Ω–æ–≤–ª—è–µ–º –∑–¥–æ—Ä–æ–≤—å–µ
          target.health = message.targetHealth;

          // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
          if (message.blocked) {
            // –≠—Ñ—Ñ–µ–∫—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ - –∫–æ—Ä–æ—Ç–∫–∞—è –≤—Å–ø—ã—à–∫–∞ —Å–∏–Ω–µ–≥–æ
            target.isBlocking = true;
            target.hitStunTimer = HIT_STUN_DURATION * 0.3; // –ú–µ–Ω—å—à–µ –æ–≥–ª—É—à–µ–Ω–∏—è –ø—Ä–∏ –±–ª–æ–∫–µ
          } else {
            // –û–±—ã—á–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è
            target.isHit = true;
            target.hitStunTimer = HIT_STUN_DURATION;
          }

          // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ—Ç–±—Ä–∞—Å—ã–≤–∞–Ω–∏–µ
          target.x += message.knockback;
          target.x = Math.max(
            0,
            Math.min(CANVAS_WIDTH - PLAYER_WIDTH, target.x)
          );

          // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –ø—Ä—ã–≥–∞–ª, –ø—Ä–∏–º–µ–Ω—è–µ–º –æ—Ç–±—Ä–∞—Å—ã–≤–∞–Ω–∏–µ –ø–æ Y
          if (target.isJumping) {
            target.velocityY = -Math.abs(message.knockback) / 2;
          }

          // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–æ—Å–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–±–∞ –∏–≥—Ä–æ–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—Ç
          if (humanPlayer && cpuOpponent) {
            updateHealthBars();
          }
        }
      }

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –ø—É–ª–∏
      function handleBulletHit(message) {
        const actionType = message.blocked
          ? "blocked bullet from"
          : "hit by bullet from";
        console.log(
          `Player ${actionType}: ${message.shooterId} ‚Üí ${message.targetId}, damage: ${message.damage}`
        );

        let target = null;
        if (message.targetId === playerId) {
          target = humanPlayer;
        } else if (cpuOpponent && cpuOpponent.networkId === message.targetId) {
          target = cpuOpponent;
        }

        if (target) {
          // –û–±–Ω–æ–≤–ª—è–µ–º –∑–¥–æ—Ä–æ–≤—å–µ
          target.health = message.targetHealth;

          // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
          if (message.blocked) {
            // –≠—Ñ—Ñ–µ–∫—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø—É–ª–∏ - –∫–æ—Ä–æ—Ç–∫–∞—è –≤—Å–ø—ã—à–∫–∞
            target.isBlocking = true;
            target.hitStunTimer = HIT_STUN_DURATION * 0.2; // –ï—â–µ –º–µ–Ω—å—à–µ –æ–≥–ª—É—à–µ–Ω–∏—è –ø—Ä–∏ –±–ª–æ–∫–µ –ø—É–ª–∏
          } else {
            // –û–±—ã—á–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è
            target.isHit = true;
            target.hitStunTimer = HIT_STUN_DURATION;
          }

          // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ—Ç–±—Ä–∞—Å—ã–≤–∞–Ω–∏–µ
          target.x += message.knockback;
          target.x = Math.max(
            0,
            Math.min(CANVAS_WIDTH - PLAYER_WIDTH, target.x)
          );

          // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –ø—Ä—ã–≥–∞–ª, –ø—Ä–∏–º–µ–Ω—è–µ–º –æ—Ç–±—Ä–∞—Å—ã–≤–∞–Ω–∏–µ –ø–æ Y
          if (target.isJumping) {
            target.velocityY = -Math.abs(message.knockback) / 2;
          }

          // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–æ—Å–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–±–∞ –∏–≥—Ä–æ–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—Ç
          if (humanPlayer && cpuOpponent) {
            updateHealthBars();
          }
        }

        // –£–¥–∞–ª—è–µ–º –ø—É–ª—é –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞
        if (message.bulletId) {
          bullets = bullets.filter((b) => b.id !== message.bulletId);
        }
      }

      // –ó–∞–ø—É—Å–∫ –º–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π –∏–≥—Ä—ã
      function startMultiplayerGame(players) {
        console.log("–ó–∞–ø—É—Å–∫ –º–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π –∏–≥—Ä—ã");

        // –°–∫—Ä—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω –æ–∫–æ–Ω—á–∞–Ω–∏—è –∏–≥—Ä—ã –µ—Å–ª–∏ –æ–Ω –±—ã–ª –ø–æ–∫–∞–∑–∞–Ω
        gameOverScreen.classList.add("hidden");

        gameState = "playing";

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∏–≥—Ä–æ–∫–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–∞
        players.forEach((player) => {
          if (player.id === playerId) {
            // –õ–æ–∫–∞–ª—å–Ω—ã–π –∏–≥—Ä–æ–∫
            humanPlayer = new Player(player.fighter, true);
            humanPlayer.networkId = player.id;
          } else {
            // –£–¥–∞–ª–µ–Ω–Ω—ã–π –∏–≥—Ä–æ–∫
            cpuOpponent = new Player(player.fighter, false);
            cpuOpponent.networkId = player.id;
            cpuOpponent.isNetworkPlayer = true;
          }
        });

        // –ü–æ–∫–∞–∑–∞—Ç—å –∏–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω
        showGameScreen();

        // –ù–∞—Å—Ç—Ä–æ–∏—Ç—å —Ö–æ–ª—Å—Ç
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // –ó–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        gameLoop();
      }

      const fighters = {
        dowand: {
          name: "Dowand",
          color: "#ff4136",
          defaultFacingRight: true,
          startX: CANVAS_WIDTH / 4 - PLAYER_WIDTH / 2,
          sprite: "tramp",
        },
        ewon: {
          name: "Ewon",
          color: "#0074d9",
          defaultFacingRight: false,
          startX: (CANVAS_WIDTH * 3) / 4 - PLAYER_WIDTH / 2,
          sprite: "mask",
        },
      };

      const SHARED_CONTROLS = {
        left: "KeyA",
        right: "KeyD",
        jump: "KeyW",
        block: "KeyS",
        shoot: "Space",
        armStrike: "KeyZ",
        legStrike: "KeyX",
      };

      class Player {
        constructor(fighterKey, isHuman = false) {
          // –ó–∞—â–∏—Ç–∞ –æ—Ç null/undefined –∑–Ω–∞—á–µ–Ω–∏–π fighterKey
          if (!fighterKey || !fighters[fighterKey]) {
            console.warn(
              `Invalid fighterKey: ${fighterKey}, using default 'dowand'`
            );
            fighterKey = "dowand"; // –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
          }

          const fighterDetails = fighters[fighterKey];
          this.x = fighterDetails.startX;
          this.y = GROUND_Y - PLAYER_HEIGHT;
          this.width = PLAYER_WIDTH;
          this.height = PLAYER_HEIGHT;
          this.baseColor = fighterDetails.color;
          this.color = fighterDetails.color;
          this.health = MAX_HEALTH;
          this.velocityY = 0;
          this.isJumping = false;
          this.currentAttackType = null;
          this.attackTimer = 0;
          this.shootCooldownTimer = 0;
          this.isBlocking = false;
          this.facingRight = fighterDetails.defaultFacingRight;
          this.isHit = false;
          this.hitStunTimer = 0;
          this.name = fighterDetails.name;
          this.isHuman = isHuman;
          this.fighterKey = fighterKey;
          if (this.isHuman) this.controls = SHARED_CONTROLS;
          else {
            // CPU specific properties
            this.aiActionInterval = 60; // Decide new action roughly every second
            this.aiActionTimer = 0;
            this.aiTargetX = null; // For movement
          }
        }
        draw() {
          // –†–∏—Å—É–µ–º —Ç–µ–Ω—å
          ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
          ctx.beginPath();
          ctx.ellipse(
            this.x + this.width / 2,
            GROUND_Y + 5,
            (this.width / 2) * 0.8,
            5,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();

          // –ï—Å–ª–∏ —Å–ø—Ä–∞–π—Ç—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã, –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å–ø—Ä–∞–π—Ç
          if (spritesLoaded) {
            let spriteToUse = null;

            // –í—ã–±–∏—Ä–∞–µ–º –Ω—É–∂–Ω—ã–π —Å–ø—Ä–∞–π—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
            if (
              this.fighterKey === "dowand" &&
              trampSprite &&
              trampSprite.complete
            ) {
              spriteToUse = trampSprite;
            } else if (
              this.fighterKey === "ewon" &&
              maskSprite &&
              maskSprite.complete
            ) {
              spriteToUse = maskSprite;
            }

            if (spriteToUse && spriteToUse.naturalWidth > 0) {
              ctx.save();

              // –ü—Ä–∏–º–µ–Ω—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã
              if (this.isHit && Math.floor(this.hitStunTimer / 4) % 2 === 0) {
                // –≠—Ñ—Ñ–µ–∫—Ç –º–∏–≥–∞–Ω–∏—è –ø—Ä–∏ —É–¥–∞—Ä–µ
                ctx.globalCompositeOperation = "lighter";
                ctx.fillStyle = "white";
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.globalCompositeOperation = "source-over";
              } else if (this.isBlocking && !this.isHit) {
                // –≠—Ñ—Ñ–µ–∫—Ç –∑–∞—Ç–µ–º–Ω–µ–Ω–∏—è –ø—Ä–∏ –±–ª–æ–∫–µ
                ctx.globalAlpha = 0.7;
              }

              // –û—Ç–∑–µ—Ä–∫–∞–ª–∏–≤–∞–µ–º —Å–ø—Ä–∞–π—Ç –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
              if (this.fighterKey === "ewon") {
                // –î–ª—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ —Å –º–∞—Å–∫–æ–π –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –ª–æ–≥–∏–∫—É –æ—Ç–∑–µ—Ä–∫–∞–ª–∏–≤–∞–Ω–∏—è
                if (this.facingRight) {
                  ctx.translate(this.x + this.width, this.y);
                  ctx.scale(-1, 1);
                  ctx.drawImage(spriteToUse, 0, 0, this.width, this.height);
                } else {
                  ctx.drawImage(
                    spriteToUse,
                    this.x,
                    this.y,
                    this.width,
                    this.height
                  );
                }
              } else {
                // –î–ª—è –æ–±—ã—á–Ω–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ (tramp) –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –±—ã–ª–æ
                if (!this.facingRight) {
                  ctx.translate(this.x + this.width, this.y);
                  ctx.scale(-1, 1);
                  ctx.drawImage(spriteToUse, 0, 0, this.width, this.height);
                } else {
                  ctx.drawImage(
                    spriteToUse,
                    this.x,
                    this.y,
                    this.width,
                    this.height
                  );
                }
              }

              ctx.restore();
            }
          } else {
            // Fallback - —Ä–∏—Å—É–µ–º –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∏ –∫–∞–∫ —Ä–∞–Ω—å—à–µ, –µ—Å–ª–∏ —Å–ø—Ä–∞–π—Ç—ã –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
            let currentFillStyle = this.baseColor;
            if (this.isHit && Math.floor(this.hitStunTimer / 4) % 2 === 0)
              currentFillStyle = "white";
            else if (this.isBlocking && !this.isHit) {
              let r = parseInt(this.baseColor.slice(1, 3), 16),
                g = parseInt(this.baseColor.slice(3, 5), 16),
                b = parseInt(this.baseColor.slice(5, 7), 16);
              currentFillStyle = `rgb(${Math.max(0, r - 50)},${Math.max(
                0,
                g - 50
              )},${Math.max(0, b - 50)})`;
            }
            ctx.fillStyle = currentFillStyle;
            const hH = this.height * 0.25,
              hW = this.width * 0.6,
              tH = this.height * 0.45,
              tW = this.width,
              lH = this.height * 0.3,
              lW = this.width * 0.8;
            const hX = this.x + (this.width - hW) / 2,
              hY = this.y;
            ctx.fillRect(hX, hY, hW, hH);
            const tX = this.x,
              tY = this.y + hH;
            ctx.fillRect(tX, tY, tW, tH);
            const lX = this.x + (this.width - lW) / 2,
              lY = this.y + hH + tH;
            ctx.fillRect(lX, lY, lW, lH);
          }

          // –†–∏—Å—É–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –∞—Ç–∞–∫ (–æ—Å—Ç–∞–µ—Ç—Å—è –∫–∞–∫ –±—ã–ª–æ)
          if (this.currentAttackType && this.attackTimer > 0) {
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –ø–æ–∑–∏—Ü–∏–π –∞—Ç–∞–∫
            const hH = this.height * 0.25;
            const tH = this.height * 0.45;

            let aX,
              aY,
              aRX,
              aRY,
              aC,
              aBaseY = this.y;
            if (this.currentAttackType === "arm") {
              aRX = ARM_STRIKE_RANGE_X;
              aRY = ARM_STRIKE_RANGE_Y;
              aY = aBaseY + hH + tH / 2 - aRY / 2;
              aC = "rgba(255,255,0,0.6)";
            } else if (this.currentAttackType === "leg") {
              aRX = LEG_STRIKE_RANGE_X;
              aRY = LEG_STRIKE_RANGE_Y;
              aY = aBaseY + hH + tH - aRY / 2;
              aC = "rgba(255,165,0,0.6)";
            }
            if (aRX) {
              aX = this.facingRight ? this.x + this.width : this.x - aRX;
              ctx.fillStyle = aC;
              ctx.fillRect(aX, aY, aRX, aRY);
            }
          }

          // –†–∏—Å—É–µ–º —ç—Ñ—Ñ–µ–∫—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
          if (this.isBlocking) {
            ctx.save();

            // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç "—â–∏—Ç–∞" –ø–µ—Ä–µ–¥ –∏–≥—Ä–æ–∫–æ–º
            const shieldX = this.facingRight
              ? this.x + this.width
              : this.x - 15;
            const shieldY = this.y + this.height * 0.2;
            const shieldWidth = 15;
            const shieldHeight = this.height * 0.6;

            // –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Å–∏–Ω–∏–π —â–∏—Ç
            ctx.fillStyle = "rgba(0, 150, 255, 0.7)";
            ctx.fillRect(shieldX, shieldY, shieldWidth, shieldHeight);

            // –î–æ–±–∞–≤–ª—è–µ–º –±–µ–ª—É—é –æ–±–≤–æ–¥–∫—É –¥–ª—è –±–æ–ª—å—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏
            ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
            ctx.lineWidth = 2;
            ctx.strokeRect(shieldX, shieldY, shieldWidth, shieldHeight);

            // –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ä—Ü–∞—é—â–∏–π —ç—Ñ—Ñ–µ–∫—Ç
            const pulseAlpha = 0.3 + 0.4 * Math.sin(Date.now() * 0.01);
            ctx.fillStyle = `rgba(200, 220, 255, ${pulseAlpha})`;
            ctx.fillRect(shieldX, shieldY, shieldWidth, shieldHeight);

            ctx.restore();
          }
        }

        update(opponent) {
          if (this.isHuman) this.updateHumanInput(opponent);
          else this.updateCpuAI(opponent);

          // –í –º–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º —Ä–µ–∂–∏–º–µ —Ñ–∏–∑–∏–∫–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è —Å–µ—Ä–≤–µ—Ä–æ–º
          if (!isMultiplayer) {
            this.y += this.velocityY;
            this.velocityY += GRAVITY;
            if (this.y + this.height >= GROUND_Y) {
              this.y = GROUND_Y - this.height;
              this.velocityY = 0;
              this.isJumping = false;
            }
            if (this.x < 0) this.x = 0;
            if (this.x + this.width > CANVAS_WIDTH)
              this.x = CANVAS_WIDTH - this.width;
          }

          if (this.shootCooldownTimer > 0) this.shootCooldownTimer--;
          if (this.currentAttackType && this.attackTimer > 0) {
            this.attackTimer--;
            if (this.attackTimer <= 0) this.currentAttackType = null;
            else this.checkMeleeHit(opponent);
          }
          if (this.hitStunTimer > 0) {
            this.hitStunTimer--;
            if (this.hitStunTimer <= 0) this.isHit = false;
          } else {
            this.color = this.baseColor;
          }
          // Basic collision push
          if (opponent) {
            const r1 = { x: this.x, y: this.y, w: this.width, h: this.height },
              r2 = {
                x: opponent.x,
                y: opponent.y,
                w: opponent.width,
                h: opponent.height,
              };
            if (
              r1.x < r2.x + r2.w &&
              r1.x + r1.w > r2.x &&
              r1.y < r2.y + r2.h &&
              r1.y + r1.h > r2.y
            ) {
              const oX = r1.x < r2.x ? r1.x + r1.w - r2.x : r2.x + r2.w - r1.x;
              if (!this.isBlocking && !opponent.isBlocking) {
                if (this.x < opponent.x) {
                  this.x -= oX / 2;
                  opponent.x += oX / 2;
                } else {
                  this.x += oX / 2;
                  opponent.x -= oX / 2;
                }
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > CANVAS_WIDTH)
                  this.x = CANVAS_WIDTH - this.width;
                if (opponent.x < 0) opponent.x = 0;
                if (opponent.x + opponent.width > CANVAS_WIDTH)
                  opponent.x = CANVAS_WIDTH - opponent.width;
              }
            }
          }
        }

        updateHumanInput(opponent) {
          if (!this.controls || Object.keys(this.controls).length === 0) return;

          const oldState = {
            x: this.x,
            y: this.y,
            velocityY: this.velocityY,
            isJumping: this.isJumping,
            facing: this.facingRight,
            blocking: this.isBlocking,
            attacking: this.currentAttackType,
            health: this.health,
          };

          this.isBlocking =
            keys[this.controls.block] &&
            !this.isJumping &&
            !this.currentAttackType &&
            !this.isHit;
          if (!this.isHit && !this.isBlocking) {
            if (keys[this.controls.left]) {
              this.x -= PLAYER_SPEED;
              this.facingRight = false;
            }
            if (keys[this.controls.right]) {
              this.x += PLAYER_SPEED;
              this.facingRight = true;
            }
          }
          if (
            keys[this.controls.jump] &&
            !this.isJumping &&
            !this.isHit &&
            !this.isBlocking
          ) {
            this.velocityY = -JUMP_FORCE;
            this.isJumping = true;
          }

          if (!this.currentAttackType && !this.isHit && !this.isBlocking) {
            if (keys[this.controls.armStrike]) {
              this.currentAttackType = "arm";
              this.attackTimer = MELEE_ATTACK_DURATION;
            } else if (keys[this.controls.legStrike]) {
              this.currentAttackType = "leg";
              this.attackTimer = MELEE_ATTACK_DURATION;
            }
          }
          if (
            keys[this.controls.shoot] &&
            this.shootCooldownTimer <= 0 &&
            !this.isHit &&
            !this.currentAttackType &&
            !this.isBlocking
          ) {
            this.shoot();
            this.shootCooldownTimer = SHOOT_COOLDOWN;
          }

          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å)
          if (isMultiplayer && this.networkId === playerId) {
            const newState = {
              x: this.x,
              y: this.y,
              velocityY: this.velocityY,
              isJumping: this.isJumping,
              facing: this.facingRight,
              blocking: this.isBlocking,
              attacking: this.currentAttackType,
              health: this.health,
            };

            const currentTime = Date.now();
            const stateChanged =
              JSON.stringify(oldState) !== JSON.stringify(newState);
            const timeToSend =
              currentTime - lastInputSent >= INPUT_SEND_INTERVAL;

            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å –∏ –ø—Ä–æ—à–ª–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤—Ä–µ–º–µ–Ω–∏,
            // –∏–ª–∏ –µ—Å–ª–∏ —ç—Ç–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ (–∞—Ç–∞–∫–∞, –±–ª–æ–∫, –ø—Ä—ã–∂–æ–∫)
            const criticalChange =
              newState.attacking !== oldState.attacking ||
              newState.blocking !== oldState.blocking ||
              newState.isJumping !== oldState.isJumping;

            if (stateChanged && (timeToSend || criticalChange)) {
              const inputData = {
                movement: {
                  x: this.x,
                  y: this.y,
                  velocityY: this.velocityY,
                  isJumping: this.isJumping,
                  facing: this.facingRight,
                },
                actions: {
                  attacking: this.currentAttackType,
                  blocking: this.isBlocking,
                },
                health: this.health,
              };

              // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –æ—Ç–ª–∏—á–∞—é—Ç—Å—è –ª–∏ –¥–∞–Ω–Ω—ã–µ –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö
              if (JSON.stringify(inputData) !== JSON.stringify(lastInputData)) {
                sendPlayerInput(inputData);
                lastInputSent = currentTime;
                lastInputData = JSON.parse(JSON.stringify(inputData)); // Deep copy
              }
            }
          }
        }
        updateCpuAI(opponent) {
          // –ï—Å–ª–∏ —ç—Ç–æ —Å–µ—Ç–µ–≤–æ–π –∏–≥—Ä–æ–∫, –Ω–µ –ø—Ä–∏–º–µ–Ω—è–µ–º –ò–ò - –µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ updateNetworkPlayers
          if (this.isNetworkPlayer && networkPlayers.has(this.networkId)) {
            return; // –í—ã—Ö–æ–¥–∏–º, –Ω–µ –≤—ã–ø–æ–ª–Ω—è—è –ò–ò –∏–ª–∏ –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—é
          }

          // –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –ò–ò –¥–ª—è –æ–¥–∏–Ω–æ—á–Ω–æ–π –∏–≥—Ä—ã
          this.aiActionTimer--;
          if (this.aiActionTimer <= 0) {
            this.aiActionTimer =
              this.aiActionInterval + Math.random() * 30 - 15; // Reset timer with some variance
            this.isBlocking = false; // Stop blocking before new action

            const distanceToOpponent = Math.abs(this.x - opponent.x);
            const randomAction = Math.random();

            if (this.isHit) return; // Don't act if stunned

            // Offensive actions
            if (
              distanceToOpponent < PLAYER_WIDTH * 2.5 &&
              !this.currentAttackType
            ) {
              if (randomAction < 0.25 && this.shootCooldownTimer <= 0) {
                this.shoot();
                this.shootCooldownTimer = SHOOT_COOLDOWN * (1 + Math.random());
              } // CPU shoots less predictably
              else if (randomAction < 0.5) {
                this.currentAttackType = "arm";
                this.attackTimer = MELEE_ATTACK_DURATION;
              } else if (randomAction < 0.75) {
                this.currentAttackType = "leg";
                this.attackTimer = MELEE_ATTACK_DURATION;
              }
            }
            // Defensive action
            if (
              opponent.currentAttackType &&
              distanceToOpponent < PLAYER_WIDTH * 3 &&
              randomAction < 0.4
            ) {
              this.isBlocking = true;
            }
            // Movement & Jump
            if (!this.isBlocking && !this.currentAttackType) {
              if (distanceToOpponent > PLAYER_WIDTH * 1.5) {
                // Move towards if far
                if (this.x < opponent.x) {
                  this.x += PLAYER_SPEED;
                  this.facingRight = true;
                } else {
                  this.x -= PLAYER_SPEED;
                  this.facingRight = false;
                }
              } else if (distanceToOpponent < PLAYER_WIDTH * 0.8) {
                // Move away if too close
                if (this.x < opponent.x) {
                  this.x -= PLAYER_SPEED / 2;
                  this.facingRight = false;
                } else {
                  this.x += PLAYER_SPEED / 2;
                  this.facingRight = true;
                }
              }
              if (randomAction > 0.85 && !this.isJumping) {
                this.velocityY = -JUMP_FORCE;
                this.isJumping = true;
              }
            }
          }
          // If CPU is blocking, it shouldn't move or initiate attacks
          if (this.isBlocking) return;
        }

        checkMeleeHit(opponent) {
          if (!this.currentAttackType || !opponent) return;

          // –í –º–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º —Ä–µ–∂–∏–º–µ —Å–µ—Ä–≤–µ—Ä –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è
          if (isMultiplayer && this.networkId === playerId) {
            // –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –≤ —Å–µ—Ç–∏ –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —É—Ä–æ–Ω –∑–¥–µ—Å—å
            // –°–µ—Ä–≤–µ—Ä –æ—Ç–ø—Ä–∞–≤–∏—Ç —Å–æ–±—ã—Ç–∏–µ playerHit –µ—Å–ª–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–æ—à–ª–æ
            return;
          }

          // –í –æ–¥–∏–Ω–æ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–ø–∞–¥–∞–Ω–∏—è –∫–∞–∫ –æ–±—ã—á–Ω–æ
          let aX,
            aY,
            aRX,
            aRY,
            dmg,
            hH = this.height * 0.25,
            tH = this.height * 0.45,
            aBaseY = this.y;
          if (this.currentAttackType === "arm") {
            aRX = ARM_STRIKE_RANGE_X;
            aRY = ARM_STRIKE_RANGE_Y;
            aY = aBaseY + hH + tH / 2 - aRY / 2;
            dmg = ARM_STRIKE_DAMAGE;
          } else if (this.currentAttackType === "leg") {
            aRX = LEG_STRIKE_RANGE_X;
            aRY = LEG_STRIKE_RANGE_Y;
            aY = aBaseY + hH + tH - aRY / 2;
            dmg = LEG_STRIKE_DAMAGE;
          } else return;
          aX = this.facingRight ? this.x + this.width : this.x - aRX;
          const attBox = { x: aX, y: aY, width: aRX, height: aRY },
            defBox = {
              x: opponent.x,
              y: opponent.y,
              width: opponent.width,
              height: opponent.height,
            };
          if (
            attBox.x < defBox.x + defBox.width &&
            attBox.x + attBox.width > defBox.x &&
            attBox.y < defBox.y + defBox.height &&
            attBox.y + attBox.height > defBox.y
          ) {
            opponent.takeDamage(dmg, this.facingRight);
            this.attackTimer = 0;
            this.currentAttackType = null; // Attack connects, end it
          }
        }
        shoot() {
          if (this.shootCooldownTimer > 0) return; // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—É–ª–¥–∞—É–Ω

          const bX = this.facingRight
            ? this.x + this.width
            : this.x - BULLET_WIDTH;
          const bY =
            this.y +
            this.height * 0.25 +
            (this.height * 0.45) / 2 -
            BULLET_HEIGHT / 2;
          const dir = this.facingRight ? 1 : -1;

          if (isMultiplayer && this.networkId === playerId) {
            // –í –º–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º —Ä–µ–∂–∏–º–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –ø—É–ª–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
            sendPlayerInput({
              newBullet: {
                x: bX,
                y: bY,
                velocityX: BULLET_SPEED * dir,
                velocityY: 0,
              },
            });
            this.shootCooldownTimer = SHOOT_COOLDOWN;
          } else {
            // –í –æ–¥–∏–Ω–æ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ —Å–æ–∑–¥–∞–µ–º –ø—É–ª—é –ª–æ–∫–∞–ª—å–Ω–æ
            const bColor = this.fighterKey === "dowand" ? "#ff9999" : "#9999ff";
            const bullet = new Bullet(bX, bY, dir, this, bColor);
            bullet.ownerId = this.networkId || this;
            bullet.velocityX = BULLET_SPEED * dir;
            bullet.velocityY = 0;
            bullets.push(bullet);
            this.shootCooldownTimer = SHOOT_COOLDOWN;
          }
        }
        takeDamage(damage, attackerFacingRight) {
          let actualDamage = damage;
          if (this.isBlocking) actualDamage *= 1 - BLOCK_DAMAGE_REDUCTION;
          this.health -= actualDamage;
          if (this.health < 0) this.health = 0;
          this.isHit = true;
          this.hitStunTimer = HIT_STUN_DURATION;
          this.currentAttackType = null;
          this.attackTimer = 0; // Interrupt attack if hit
          if (attackerFacingRight) this.x += KNOCKBACK_FORCE;
          else this.x -= KNOCKBACK_FORCE;
          if (this.isJumping) this.velocityY = -KNOCKBACK_FORCE / 2;
          updateHealthBars();
        }
        reset() {
          this.x = fighters[this.fighterKey].startX;
          this.y = GROUND_Y - PLAYER_HEIGHT;
          this.health = MAX_HEALTH;
          this.velocityY = 0;
          this.isJumping = false;
          this.currentAttackType = null;
          this.attackTimer = 0;
          this.shootCooldownTimer = 0;
          this.isHit = false;
          this.hitStunTimer = 0;
          this.isBlocking = false;
          this.facingRight = fighters[this.fighterKey].defaultFacingRight;
          this.color = this.baseColor;
        }
      }
      class Bullet {
        constructor(x, y, direction, owner, color = "#fff000") {
          Object.assign(this, { x, y, direction, owner, color });
          this.width = BULLET_WIDTH;
          this.height = BULLET_HEIGHT;
          this.speed = BULLET_SPEED;
          this.velocityX = BULLET_SPEED * direction;
          this.velocityY = 0;
        }
        draw() {
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
        update() {
          this.x += this.velocityX;
          this.y += this.velocityY;
        }
      }

      function updateHealthBars() {
        // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–≤
        if (!humanPlayer || !cpuOpponent) {
          return; // –í—ã—Ö–æ–¥–∏–º, –µ—Å–ª–∏ –∏–≥—Ä–æ–∫–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã
        }

        const p1 =
          humanPlayer.fighterKey === "dowand" ? humanPlayer : cpuOpponent;
        const p2 =
          humanPlayer.fighterKey === "dowand" ? cpuOpponent : humanPlayer;

        if (player1HealthBar && p1) {
          player1HealthBar.style.width = (p1.health / MAX_HEALTH) * 100 + "%";
        }
        if (player2HealthBar && p2) {
          player2HealthBar.style.width = (p2.health / MAX_HEALTH) * 100 + "%";
        }
      }

      function handleBulletCollisions() {
        // –í –º–Ω–æ–≥–æ–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º —Ä–µ–∂–∏–º–µ –ù–ï –æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ –ø—É–ª—å - —ç—Ç–æ –¥–µ–ª–∞–µ—Ç —Å–µ—Ä–≤–µ—Ä
        if (isMultiplayer) {
          // –¢–æ–ª—å–∫–æ —É–¥–∞–ª—è–µ–º –ø—É–ª–∏, –≤—ã–ª–µ—Ç–µ–≤—à–∏–µ –∑–∞ —ç–∫—Ä–∞–Ω (–¥–ª—è –ø–æ–¥—Å—Ç—Ä–∞—Ö–æ–≤–∫–∏)
          for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            if (bullet.x + bullet.width < -50 || bullet.x > CANVAS_WIDTH + 50) {
              bullets.splice(i, 1);
            }
          }
          return; // –ö–æ–ª–ª–∏–∑–∏–∏ –∏ –¥–≤–∏–∂–µ–Ω–∏–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–µ—Ä–≤–µ—Ä
        }

        // –í –æ–¥–∏–Ω–æ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ –∏ –¥–≤–∏–∂–µ–Ω–∏–µ –∫–∞–∫ –æ–±—ã—á–Ω–æ
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.update(); // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Ç–æ–ª—å–∫–æ –≤ –æ–¥–∏–Ω–æ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ
          if (bullet.x + bullet.width < 0 || bullet.x > CANVAS_WIDTH) {
            bullets.splice(i, 1);
            continue;
          }

          const target =
            bullet.owner === humanPlayer ? cpuOpponent : humanPlayer;
          if (target && !target.isHit) {
            const bBox = {
                x: bullet.x,
                y: bullet.y,
                w: bullet.width,
                h: bullet.height,
              },
              pBox = {
                x: target.x,
                y: target.y,
                w: target.width,
                h: target.height,
              };
            if (
              bBox.x < pBox.x + pBox.w &&
              bBox.x + bBox.w > pBox.x &&
              bBox.y < pBox.y + pBox.h &&
              bBox.y + bBox.h > pBox.y
            ) {
              if (!target.isBlocking) {
                // Only do damage if not blocking
                target.takeDamage(BULLET_DAMAGE, bullet.direction > 0);
              } else {
                // Bullet hits block, still apply hitstun/knockback
                target.isHit = true;
                target.hitStunTimer = HIT_STUN_DURATION;
                if (bullet.direction > 0) target.x += KNOCKBACK_FORCE / 2;
                else target.x -= KNOCKBACK_FORCE / 2;
              }
              bullets.splice(i, 1);
              break;
            }
          }
        }
      }

      function checkGameOver() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∏–≥—Ä–æ–∫–∏ —Å—É—â–µ—Å—Ç–≤—É—é—Ç –ø–µ—Ä–µ–¥ –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∑–¥–æ—Ä–æ–≤—å—è
        if (!humanPlayer || !cpuOpponent) {
          return; // –ù–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º –æ–∫–æ–Ω—á–∞–Ω–∏–µ –∏–≥—Ä—ã –µ—Å–ª–∏ –∏–≥—Ä–æ–∫–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã
        }

        let winner = null;
        if (humanPlayer.health <= 0) {
          winner = cpuOpponent;
        } else if (cpuOpponent.health <= 0) {
          winner = humanPlayer;
        }

        if (winner) {
          gameState = "gameOver";
          winnerMessage.textContent = `${winner.name} Wins!`;
          gameOverScreen.classList.remove("hidden");
          document.getElementById("healthBars").classList.add("hidden");
          if (animationFrameId) cancelAnimationFrame(animationFrameId);
        }
      }

      function gameLoop() {
        if (gameState !== "playing") return;

        // –û–±–Ω–æ–≤–ª—è–µ–º –∏–≥—Ä–æ–∫–æ–≤ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞ –∏–≥—Ä—ã
        if (humanPlayer) {
          if (isMultiplayer) {
            // –í —Å–µ—Ç–µ–≤–æ–π –∏–≥—Ä–µ –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
            humanPlayer.update(cpuOpponent);

            // –£–¥–∞–ª–µ–Ω–Ω—ã–π –∏–≥—Ä–æ–∫ –Ω–µ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ - —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ —Å–µ—Ç—å
            if (cpuOpponent && cpuOpponent.isNetworkPlayer) {
              // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–∞–π–º–µ—Ä—ã –∏ –∞–Ω–∏–º–∞—Ü–∏–∏ –¥–ª—è —Å–µ—Ç–µ–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞
              if (cpuOpponent.attackTimer > 0) {
                cpuOpponent.attackTimer--;
                if (cpuOpponent.attackTimer <= 0) {
                  cpuOpponent.currentAttackType = null;
                }
              }
              if (cpuOpponent.hitStunTimer > 0) {
                cpuOpponent.hitStunTimer--;
                if (cpuOpponent.hitStunTimer <= 0) {
                  cpuOpponent.isHit = false;
                }
              }
              if (cpuOpponent.shootCooldownTimer > 0) {
                cpuOpponent.shootCooldownTimer--;
              }
            }
          } else {
            // –í –æ–¥–∏–Ω–æ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ –æ–±–Ω–æ–≤–ª—è–µ–º –æ–±–æ–∏—Ö –∏–≥—Ä–æ–∫–æ–≤ –∫–∞–∫ –æ–±—ã—á–Ω–æ
            humanPlayer.update(cpuOpponent);
            if (cpuOpponent) {
              cpuOpponent.update(humanPlayer);
            }
          }
        }

        handleBulletCollisions();

        // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, GROUND_Y);
        ctx.lineTo(CANVAS_WIDTH, GROUND_Y);
        ctx.stroke();

        // –†–∏—Å—É–µ–º –∏–≥—Ä–æ–∫–æ–≤
        if (humanPlayer) humanPlayer.draw();
        if (cpuOpponent) cpuOpponent.draw();

        // –†–∏—Å—É–µ–º –ø—É–ª–∏
        bullets.forEach((bullet) => bullet.draw());

        checkGameOver();
        animationFrameId = requestAnimationFrame(gameLoop);
      }

      // Navigation functions between screens
      function showCharacterSelectionScreen() {
        currentScreen = "character";
        characterSelectionScreen.classList.remove("hidden");
        gameModeSelectionScreen.classList.add("hidden");
        waitingScreen.classList.add("hidden");
        gameMainContainer.classList.add("hidden");
        gameUiContainer.classList.remove("hidden");
        document.getElementById("healthBars").classList.add("hidden");
      }

      function showGameModeSelectionScreen() {
        currentScreen = "gamemode";
        characterSelectionScreen.classList.add("hidden");
        gameModeSelectionScreen.classList.remove("hidden");
        waitingScreen.classList.add("hidden");
        gameMainContainer.classList.add("hidden");
        gameUiContainer.classList.remove("hidden");

        // Update selected fighter display
        const selectedFighterName = document.getElementById(
          "selectedFighterName"
        );
        selectedFighterName.textContent = fighters[selectedFighter].name;
      }

      function showWaitingScreen(mode) {
        currentScreen = "waiting";
        characterSelectionScreen.classList.add("hidden");
        gameModeSelectionScreen.classList.add("hidden");
        waitingScreen.classList.remove("hidden");
        gameMainContainer.classList.add("hidden");
        gameUiContainer.classList.remove("hidden");

        const waitingTitle = document.getElementById("waitingTitle");
        const waitingSubtitle = document.getElementById("waitingSubtitle");
        const queueStatus = document.getElementById("queueStatus");
        const roomStatus = document.getElementById("roomStatus");

        if (mode === "queue") {
          waitingTitle.textContent = "Finding Match...";
          waitingSubtitle.textContent = `Playing as ${fighters[selectedFighter].name}`;
          queueStatus.style.display = "block";
          roomStatus.style.display = "none";
        } else if (mode === "room") {
          waitingTitle.textContent = "Private Room";
          waitingSubtitle.textContent = `Playing as ${fighters[selectedFighter].name}`;
          queueStatus.style.display = "none";
          roomStatus.style.display = "block";
        }
      }

      function showGameScreen() {
        currentScreen = "game";
        characterSelectionScreen.classList.add("hidden");
        gameModeSelectionScreen.classList.add("hidden");
        waitingScreen.classList.add("hidden");
        gameUiContainer.classList.add("hidden");
        gameMainContainer.classList.remove("hidden");
        document.getElementById("healthBars").classList.remove("hidden");
      }

      function showFighterSelectionScreen() {
        showCharacterSelectionScreen();
        gameState = "selecting";
        gameOverScreen.classList.add("hidden");
      }

      // Event listeners for character selection
      document.getElementById("selectDowand").addEventListener("click", () => {
        selectedFighter = "dowand";
        showGameModeSelectionScreen();
      });

      document.getElementById("selectEwon").addEventListener("click", () => {
        selectedFighter = "ewon";
        showGameModeSelectionScreen();
      });

      // Event listeners for game mode selection
      document.getElementById("quickMatchBtn").addEventListener("click", () => {
        if (!selectedFighter) return;

        // Send fighter selection to server before joining queue
        if (ws && ws.readyState === WebSocket.OPEN) {
          sendToServer({
            type: "selectFighter",
            fighter: selectedFighter,
          });
        }

        showWaitingScreen("queue");
        joinQueue();
      });

      document.getElementById("createRoomBtn").addEventListener("click", () => {
        if (!selectedFighter) return;
        showWaitingScreen("room");
        createRoom();
      });

      document.getElementById("joinRoomBtn").addEventListener("click", () => {
        if (!selectedFighter) return;
        const roomIdInput = document.getElementById("roomIdInput").value;
        if (roomIdInput) {
          showWaitingScreen("room");
          joinRoom(roomIdInput);
        }
      });

      document
        .getElementById("backToCharacterBtn")
        .addEventListener("click", () => {
          showCharacterSelectionScreen();
        });

      // Event listeners for waiting screen
      document.getElementById("readyBtn").addEventListener("click", () => {
        if (!selectedFighter) return;

        // Send fighter selection to server
        sendToServer({
          type: "selectFighter",
          fighter: selectedFighter,
        });

        setReady();
        document.getElementById("readyBtn").disabled = true;
        document.getElementById("readyBtn").textContent = "Waiting...";
      });

      document.getElementById("cancelBtn").addEventListener("click", () => {
        if (inQueue) {
          leaveQueue();
        } else if (roomId) {
          roomId = null;
          document.getElementById("readyBtn").style.display = "none";
        }
        showGameModeSelectionScreen();
      });

      playAgainButton.addEventListener("click", () => {
        // –°–∫—Ä—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω –æ–∫–æ–Ω—á–∞–Ω–∏—è –∏–≥—Ä—ã
        gameOverScreen.classList.add("hidden");

        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞
        if (isMultiplayer) {
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–µ—Ä–≤–µ—Ä—É –æ –≤—ã—Ö–æ–¥–µ –∏–∑ –∫–æ–º–Ω–∞—Ç—ã
          if (ws && ws.readyState === WebSocket.OPEN) {
            sendToServer({ type: "leaveRoom" });
          }

          isMultiplayer = false;
          roomId = null;

          // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–≤
          humanPlayer = null;
          cpuOpponent = null;
          bullets = [];

          // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
          gameState = "selecting";

          // –û—Ç–º–µ–Ω—è–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –µ—Å–ª–∏ –æ–Ω–∞ –±—ã–ª–∞ –∑–∞–ø—É—â–µ–Ω–∞
          if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
          }
        }

        showCharacterSelectionScreen();
      });

      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI —Å–µ—Ç–∏
      function updateNetworkUI() {
        const connectionStatus = document.getElementById("connectionStatus");
        const pingInfo = document.getElementById("pingInfo");
        const pingValue = document.getElementById("pingValue");

        if (ws && ws.readyState === WebSocket.OPEN) {
          connectionStatus.textContent = "Connected";
          connectionStatus.style.color = "#00ff00";
          pingInfo.style.display = "block";
          pingValue.textContent = latency;
        } else {
          connectionStatus.textContent = "Disconnected";
          connectionStatus.style.color = "#ff0000";
          pingInfo.style.display = "none";
        }
      }

      // –û–±–Ω–æ–≤–ª—è–µ–º UI –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
      setInterval(updateNetworkUI, 1000);

      window.addEventListener("keydown", (e) => {
        keys[e.code] = true;
        if (
          gameState === "playing" &&
          humanPlayer &&
          humanPlayer.controls &&
          Object.values(humanPlayer.controls).includes(e.code)
        )
          e.preventDefault();
      });
      window.addEventListener("keyup", (e) => {
        keys[e.code] = false;
      });

      function setupDynamicTouchControls() {
        const tc = document.getElementById("touchControlsContainer");
        if (
          !humanPlayer ||
          !humanPlayer.controls ||
          Object.keys(humanPlayer.controls).length === 0
        ) {
          tc.innerHTML = "";
          tc.classList.add("hidden");
          return;
        }
        const touchLayoutHTML = `<div class="touch-controls-group"><div class="touch-movement"><button class="touch-button" id="tc_Left">&#x2190;</button><button class="touch-button" id="tc_Right">&#x2192;</button><button class="touch-button" id="tc_Jump">&#x2191;</button></div><div class="touch-actions"><button class="touch-button" id="tc_Block">BLK</button><button class="touch-button" id="tc_Arm">ARM</button><button class="touch-button" id="tc_Leg">LEG</button><button class="touch-button" id="tc_Shoot">SHT</button></div></div>`;
        tc.innerHTML = touchLayoutHTML;
        tc.classList.remove("hidden");
        const touchMap = {
          tc_Left: "left",
          tc_Right: "right",
          tc_Jump: "jump",
          tc_Block: "block",
          tc_Arm: "armStrike",
          tc_Leg: "legStrike",
          tc_Shoot: "shoot",
        };
        Object.keys(touchMap).forEach((btnId) => {
          const btn = document.getElementById(btnId);
          if (btn) {
            const kCode = humanPlayer.controls[touchMap[btnId]];
            btn.addEventListener(
              "touchstart",
              (e) => {
                e.preventDefault();
                keys[kCode] = true;
                btn.style.backgroundColor = "rgba(224,62,0,0.9)";
              },
              { passive: false }
            );
            btn.addEventListener(
              "touchend",
              (e) => {
                e.preventDefault();
                keys[kCode] = false;
                btn.style.backgroundColor = "rgba(255,69,0,0.7)";
              },
              { passive: false }
            );
          }
        });
      }

      function handlePageLoad() {
        // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ WebSocket —Å–µ—Ä–≤–µ—Ä—É
        connectToServer();

        // –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∂–∞–µ–º —Å–ø—Ä–∞–π—Ç—ã
        loadSprites()
          .then(() => {
            console.log("–°–ø—Ä–∞–π—Ç—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã!");
            showFighterSelectionScreen(); // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ø—Ä–∞–π—Ç–æ–≤
          })
          .catch((error) => {
            console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ø—Ä–∞–π—Ç–æ–≤:", error);
            showFighterSelectionScreen(); // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω –¥–∞–∂–µ –µ—Å–ª–∏ —Å–ø—Ä–∞–π—Ç—ã –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∏—Å—å
          });

        // Setup canvas initial dimensions for responsive scaling.
        const gameContainer = document.getElementById("gameContainer");
        const containerWidth = Math.min(window.innerWidth * 0.9, 800);
        const scale = containerWidth / CANVAS_WIDTH;
        gameContainer.style.width = CANVAS_WIDTH * scale + "px";
        gameContainer.style.height = CANVAS_HEIGHT * scale + "px";

        // UI container can have its own sizing logic if needed
        const uiCont = document.getElementById("uiContainer");
        uiCont.style.maxWidth = "600px"; // Example max width for UI
        uiCont.style.width = "90%";
      }

      window.addEventListener("resize", () => {
        const c = document.getElementById("gameContainer");
        if (c.classList.contains("hidden") && gameState !== "playing") return; // Don't resize if game not active

        const containerWidth = Math.min(window.innerWidth * 0.9, 800);
        const scale = containerWidth / CANVAS_WIDTH;
        c.style.width = CANVAS_WIDTH * scale + "px";
        c.style.height = CANVAS_HEIGHT * scale + "px";
      });

      // Initialize
      handlePageLoad();
    </script>
  </body>
</html>
